---
slug: 'deploying-an-url-shortener-on-aws'
title: 'Deploying an URL shortener on AWS'
pubDate: 2025-08-13T18:04:10.163Z
draft: true
tags:
  - cloud
  - aws
  - spring
---

## 0. Introduction

In this article, I'll detail my experience deploying a simple application on AWS. Since it was my first time really working with AWS (and cloud in general), I didn't use any IaC language, so the entire setup was done through the AWS console. I'm planning to recreate this deployment using Terraform in the future.

But before talking about my AWS experience, I'll give you an overview of the application itself.

## 1. The application

Since the application was not the focus on this project, I built a simple URL shortener and divided it in two components: backend and frontend. Its source code can be found [here](https://github.com/davisiqueira1/url-shortener).

### 1.1 Backend

The backend was built using Spring Boot. Its core functionality is to take a long URL and generate a short code, mapping it back to the long URL. To add another feature, I decided to make the short codes expire 7 days after their creation.

To implement this expiration date, I chose to use MongoDB as my database, since it has built-in TTL (time to live) indexing and can be easily integrated with Spring Boot by adding a dependency named [Spring Data MongoDB](https://spring.io/projects/spring-data-mongodb).

With that said, let's define our entity model:

```java
@Document(collection = "url")
@Setter
@Getter
@NoArgsConstructor
@AllArgsConstructor
public class UrlModel {
    @Id
    private String id;

    private String longUrl;
    private String shortCode;

    @Indexed(name = "expirationDate_ttl", expireAfter = "0s")
    private Date expirationDate;
}
```

As you can see, the model is quite straightforward: an ID managed by MongoDB, two strings used to map to each other and an expirationDate indexed by the database.

A detailed review of the API's internal logic is beyond the scope of this article. For our purposes, it's sufficient to understand its interface, just as the frontend does.

The API exposes two endpoints:

- `/api/shorten`: given a long URL, it returns a short code mapping back to the url.
- `/{shortCode}`: given a short code, it redirects the user to the corresponding long URL.

Only one thing in this project is simpler than our backend: our frontend.

### 1.2 Frontend

The frontend was so simple that I built it using HTML, CSS, and JavaScript.

One page, one input and one button: that's all we need.

<img src="/assets/url-shortener-frontend.png" width="150"/><br><br>

## Deploying it on AWS

Let's start our really long journey by defining what's our goal.

At the end of this article we'll have configured two routes of services:

1. Frontend: User -> CloudFront -> S3
2. API calls: Frontend -> ALB (Load Balancer) -> Nginx (EC2) -> Spring Boot -> MongoDB

So, let's cut to action.

### Unexpected start: database deployment

To start our journey deploying things on AWS we'll host our MongoDB on... _(drum roll)_ ... MongoDB Atlas!!!!

I know, I know, MongoDB Atlas isn't an AWS service... I know, you can stop throwing tomatoes at me now.

That's the only regret I have on this project: I didn't plan the whole thing when I was coding the backend. As I told you in the beginning of this article, it was my first time working with AWS, so I didn't know they don't have a (N)RDS service.

I know you can install and run MongoDB on an EC2 instance, but that was not my goal. Didn't use DynamoDB too (but I'm planning to try it in the future!), so the last option was hosting it on MongoDB Atlas.

_Side note: as I was writing this, I found out that AWS offers a service that emulates MongoDB, it's called [DocumentDB](https://aws.amazon.com/pt/documentdb/)._

The step-by-step is straightforward: just create an [account](https://account.mongodb.com/account/register) and instantiate a flex cluster.
